This bug is a race between uselib() and msync()  
  
Install Ubuntu 4.10 on Vmware workstation (Number of processors:2 & Number of cores per processor:2)  
http://old-releases.ubuntu.com/releases/warty/  
  
build and install the kernel:  
sudo apt-get install kernel-tree-2.6.7  
mkdir build  
cd build  
apt-get source kernel-image-2.6.7-1-686-smp  
cd kernel-image-2.6.7-i386-2.6.7  
// remove all files in config except "686-smp", "default"  
fakeroot debian/rules unpack  
// apply patches in build-686-smp  
fakeroot debian/rules binary  
cd ..  
sudo dpkg -i kernel-image-2.6.7-1-686-smp_2.6.7-1ubuntu2_i386.deb  
// The grub settings will be updated accordingly.  
  
gcc msync-2sleep.c -lpthread   
./a.out  

Check the message buffer of the kernel by dmesg. We can see "f_dentry is null" and kernel panics.
  
However, I don't think we can do this with one sleep only.  
We null out the f_dentry by fput(), which only happens when it is called with file->f_count == 1.  
In kernel 2.4.26, we produce the desired effect by creating a file, mapping to it, and then closing the file.  
In kernel 2.6.7, the call chain is as follows.  
    `split_vma() -> unmap_vma_list()`  
In split_vma(), we try to sleep on kmem_cache_alloc (by consuming VMA slab entries and forcing memory reclamation).  
In unmap_vma_list(), fput() is called to null out f_dentry.  
Nonetheless, in split_vma(), [get_file()](http://lxr.oss.org.cn/source/mm/mmap.c?v=2.6.8#L1534) is invoked which increases file->f_count by 1.
